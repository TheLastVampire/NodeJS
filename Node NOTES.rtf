-Node.js is really two things: a runtime environment and a library
• We want to serve web pages, therefore we need an HTTP server
• Our server will need to answer differently to requests, depending on which URL the request was asking for, thus we need some kind of router in order to map requests to request handlers
• To fullfill the requests that arrived at the server and have been routed using the router, we need actual request handlers
• The router probably should also treat any incoming POST data and give it to the request handlers in a convenient form, thus we need request data handling
• We not only want to handle requests for URLs, we also want to display content when these URLs are requested, which means we need some kind of view logic the request handlers can use in order to send content to the user’s browser
• Last but not least, the user will be able to upload images, so we are going to need some kind of upload handling which takes care of the details
-With Node.js, we not only implement our application, we also implement the whole HTTP server. In fact, our web application and its web server are basically the same.
-Making different HTTP requests point at different parts of ourcode is called “routing”
-We need to be able to feed the requested URL and possible additional GET and POST parameters into our router, and based on these the router then needs to be able to decide which code to execute (this “code to execute” is the third part of our application: a collection of request handlers that do the actual work when a request is received).
-In C++ or C#, when weâ€™re talking about objects, we’re referring to instances of classes or structs. Objects have different properties and methods, depending on which templates (that is, classes) they are instantiated from. That’s not the case with JavaScript objects. In JavaScript, objects are just collections of name/value pairs - think of a JavaScript object as a dictionary with string keys.
*Once you load JavaScript code into a web page, it is injected into the global namespace, which is a common addressing space shared by all other scripts that have been loaded. This can lead to security issues, conflicts, and general bugs that are hard to trace and solve. Thankfully, Node brings some order in this regard to server-side JavaScript and implements the CommonJS modules standard. In this standard each module has its own context, separated from the other modules. This means that modules cannot pollute a global scope — because there is none — and cannot interfere with other modules.
*In Node, modules are referenced either by fi le path or by name
*Modules are cached the fi rst time they are loaded, which means that every call to require('myModule') returns exactly the same module if the module name resolves to the exact same fi lename.
