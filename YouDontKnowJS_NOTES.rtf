[Hoisting] (https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md#hoisting)
*var vs let vs no var auto-global declarations: https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md#function-scopes
in short - var: available everywhere in the current scope. It's available at the top of the scope even if it's declared at the bottom in that scope - this is HOISTING. Like flag-hoisitng, the variable declaration (usually function) is hoisted to the top of the scope. Note that even if you declare var a = 0; inside a nested {} in a function, if that line of code is hit it will still be available throughout the function.
let: this creates BLOCK scope - it's scoped inside {}, as oposed to var that's scoped to function
no keyword declaration (like a=0;): auto-global scope. available globally - bad practice!
[Immediately Invoked Function Expressions (IIFEs)](https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md#immediately-invoked-function-expressions-iifes)
[Intro to closures] (https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md#closure)
*The most common usage of closure in JavaScript is the module pattern
[this identifier](https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md#this-identifier)
*The most common way this feature (Prototypes) is used -- and I would argue, abused -- is to try to emulate/fake a "class" mechanism with "inheritance." But a more natural way of applying prototypes is a pattern called "behavior delegation," where you intentionally design your linked objects to be able to delegate from one to the other for parts of the needed behavior.
*Polyfilling and Transpiling
